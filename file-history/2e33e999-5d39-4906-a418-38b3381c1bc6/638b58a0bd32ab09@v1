import { ILogger } from "@generatezero/ports/logger";

import { BulkOrganisationUploadInput } from "../interfaces/OrganisationRepository.interface";
import { ORGANISATION_TEMPLATE_CSV_COLUMNS } from "../parsers/constants/OrganisationTemplateCsvParser.constants";
import { OrganisationService } from "../services/Organisation.service";

const mockLogger: ILogger = {
  info: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
  debug: jest.fn(),
  trace: jest.fn(),
  critical: jest.fn(),
  flush: jest.fn(),
  setService: jest.fn()
};

const mockOrganisationRepository = {
  getManyBy: jest.fn(),
  createOrganisation: jest.fn(),
  bulkUploadOrganisations: jest.fn()
};
const mockTagRepository = {
  getManyTagsByNames: jest.fn(),
  createManyTags: jest.fn()
};
const mockFinancialYearRepository = { getManyBy: jest.fn() };
const mockFinancialQuarterRepository = { getManyBy: jest.fn() };
const mockMonthRepository = { getManyBy: jest.fn() };

const CSV_HEADER = Array.from(Object.values(ORGANISATION_TEMPLATE_CSV_COLUMNS));

function createCsvBuffer(rows: string[][]): Buffer {
  const csvContent = rows
    .map((row) =>
      row.map((cell) => (cell.includes(",") ? `"${cell}"` : cell)).join(",")
    )
    .join("\n");
  return Buffer.from(csvContent, "utf8");
}

describe("OrganisationService.uploadOrganisationTemplate", () => {
  let service: OrganisationService;
  const defaultParentOrgInfo = {
    financialYearStartMonthIndex: 0,
    reportingStandardId: "GHG_PROTOCOL",
    consolidationApproachId: "OPERATIONAL"
  };

  const mockMonths = Array.from({ length: 72 }, (_, i) => ({
    id: i,
    startDate: new Date(2020 + Math.floor(i / 12), i % 12, 1),
    endDate: new Date(2020 + Math.floor(i / 12), (i % 12) + 1, 0)
  }));

  beforeEach(() => {
    jest.clearAllMocks();
    mockOrganisationRepository.getManyBy.mockResolvedValue([]);
    mockMonthRepository.getManyBy.mockResolvedValue(mockMonths);
    mockTagRepository.getManyTagsByNames.mockResolvedValue([]);
    mockTagRepository.createManyTags.mockImplementation(async (tags) =>
      tags.map((tag: { name: string }) => ({
        id: `tag-${tag.name}`,
        name: tag.name
      }))
    );
    mockFinancialYearRepository.getManyBy.mockResolvedValue(
      Array.from({ length: 5 }, (_, i) => ({
        id: i + 1,
        startMonth: mockMonths[i * 12],
        endMonth: mockMonths[i * 12 + 11]
      }))
    );
    mockFinancialQuarterRepository.getManyBy.mockResolvedValue(
      Array.from({ length: 20 }, (_, i) => ({
        id: i + 1,
        startMonth: mockMonths[i * 3],
        endMonth: mockMonths[i * 3 + 2]
      }))
    );
    mockOrganisationRepository.bulkUploadOrganisations.mockImplementation(
      async (input: BulkOrganisationUploadInput) =>
        input.organisationUnits.length
    );

    service = new OrganisationService(
      mockLogger,
      {} as never,
      mockOrganisationRepository as never,
      mockTagRepository as never,
      {} as never,
      {} as never,
      {} as never,
      mockFinancialYearRepository as never,
      mockFinancialQuarterRepository as never,
      {} as never,
      mockMonthRepository as never
    );
  });

  it("should create organisations with correct hierarchy", async () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Parent", "", "", "01/01/2024", "", ""],
      ["Child", "", "Parent", "01/01/2024", "", ""]
    ]);

    await service.uploadOrganisationTemplate(csvBuffer, defaultParentOrgInfo);

    expect(
      mockOrganisationRepository.bulkUploadOrganisations
    ).toHaveBeenCalledTimes(1);

    const callArgs =
      mockOrganisationRepository.bulkUploadOrganisations.mock.calls[0][0];
    expect(callArgs.organisationUnits).toHaveLength(2);
    expect(callArgs.organisationUnits[0]).toMatchObject({
      name: "Parent",
      parentName: undefined
    });
    expect(callArgs.organisationUnits[1]).toMatchObject({
      name: "Child",
      parentName: "Parent"
    });
  });

  it("should create and assign tags correctly", async () => {
    mockTagRepository.getManyTagsByNames.mockResolvedValue([
      { id: "existing-id", name: "Existing" }
    ]);
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Org", "", "", "01/01/2024", "", "Existing, New"]
    ]);

    await service.uploadOrganisationTemplate(csvBuffer, defaultParentOrgInfo);

    expect(mockTagRepository.createManyTags).not.toHaveBeenCalled();

    const callArgs =
      mockOrganisationRepository.bulkUploadOrganisations.mock.calls[0][0];
    expect(callArgs.organisationUnits[0].tags).toContain("Existing");
    expect(callArgs.organisationUnits[0].tags).toContain("New");
    expect(callArgs.existingTagMap.get("Existing")).toBe("existing-id");
    expect(callArgs.tagsToCreate).toEqual([{ name: "New", description: null }]);
  });

  it("should use parent organisation info for root org", async () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "01/01/2024", "", ""]
    ]);

    await service.uploadOrganisationTemplate(csvBuffer, {
      financialYearStartMonthIndex: 6,
      reportingStandardId: "ISO_14064",
      consolidationApproachId: "EQUITY"
    });

    const callArgs =
      mockOrganisationRepository.bulkUploadOrganisations.mock.calls[0][0];
    expect(callArgs.organisationUnits[0]).toMatchObject({
      reportingStandardId: "ISO_14064",
      consolidationApproachId: "EQUITY"
    });
  });

  it("should throw error when organisations already exist", async () => {
    mockOrganisationRepository.getManyBy.mockResolvedValue([{ id: 1 }]);
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["New", "", "", "01/01/2024", "", ""]
    ]);

    await expect(
      service.uploadOrganisationTemplate(csvBuffer, defaultParentOrgInfo)
    ).rejects.toThrow(/already exists/);
  });

  it("should return count of created organisations", async () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "01/01/2024", "", ""],
      ["Child1", "", "Root", "01/01/2024", "", ""],
      ["Child2", "", "Root", "01/01/2024", "", ""]
    ]);

    const result = await service.uploadOrganisationTemplate(
      csvBuffer,
      defaultParentOrgInfo
    );

    expect(result).toBe(3);
  });

  it("should pass financial years and quarters to bulk upload", async () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "01/01/2024", "", ""]
    ]);

    await service.uploadOrganisationTemplate(csvBuffer, defaultParentOrgInfo);

    const callArgs =
      mockOrganisationRepository.bulkUploadOrganisations.mock.calls[0][0];
    expect(callArgs.rootOrgFinancialYears.length).toBeGreaterThan(0);
    expect(callArgs.rootOrgFinancialQuarters.length).toBeGreaterThan(0);
  });

  it("should not create tags if all tags already exist", async () => {
    mockTagRepository.getManyTagsByNames.mockResolvedValue([
      { id: "tag-1", name: "Tag1" },
      { id: "tag-2", name: "Tag2" }
    ]);
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Org", "", "", "01/01/2024", "", "Tag1, Tag2"]
    ]);

    await service.uploadOrganisationTemplate(csvBuffer, defaultParentOrgInfo);

    const callArgs =
      mockOrganisationRepository.bulkUploadOrganisations.mock.calls[0][0];
    expect(callArgs.tagsToCreate).toEqual([]);
    expect(callArgs.existingTagMap.get("Tag1")).toBe("tag-1");
    expect(callArgs.existingTagMap.get("Tag2")).toBe("tag-2");
  });

  it("should only set reporting standard and consolidation approach on root org", async () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "01/01/2024", "", ""],
      ["Child", "", "Root", "01/01/2024", "", ""]
    ]);

    await service.uploadOrganisationTemplate(csvBuffer, defaultParentOrgInfo);

    const callArgs =
      mockOrganisationRepository.bulkUploadOrganisations.mock.calls[0][0];
    expect(callArgs.organisationUnits[0].reportingStandardId).toBe(
      "GHG_PROTOCOL"
    );
    expect(callArgs.organisationUnits[0].consolidationApproachId).toBe(
      "OPERATIONAL"
    );
    expect(callArgs.organisationUnits[1].reportingStandardId).toBeUndefined();
    expect(
      callArgs.organisationUnits[1].consolidationApproachId
    ).toBeUndefined();
  });
});
