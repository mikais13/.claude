import { TenantPrisma, TenantPrismaRepository } from "@generatezero/db";

import { OrganisationHierarchy } from "@/server/modules/Organisation/models/OrganisationHeirachy.model";
import { FinancialQuarterInputArgs } from "../../Date/interfaces/FinancialQuarterRepository.interface";
import { FinancialYearInputArgs } from "../../Date/interfaces/FinancialYearRepository.interface";
import { EmissionsFilterBy } from "../../Emissions/interfaces/EmissionsRepository.interface";
import {
  BulkOrganisationUploadInput,
  IOrganisationRepository,
  OrganisationCreateArgs,
  OrganisationUnitArgs,
  OrganisationUnitMinimalDto,
  OrganisationUpdateArgs
} from "../interfaces/OrganisationRepository.interface";
import { FacilityTemplateProcessingResult } from "../interfaces/OrganisationUpload.interface";
import { OrganisationUnitDto } from "../models/OrganisationUnit.model";

export class OrganisationRepository
  extends TenantPrismaRepository
  implements IOrganisationRepository
{
  async getTopOrgUnitReportingStandardId(): Promise<string> {
    const topOrg = await this.client.organisationUnit.findFirst({
      where: {
        parentId: null
      }
    });

    if (!topOrg) {
      this.logger.warn(
        `No top-level organization unit found with parentId: null`
      );
      throw new Error(
        "No top-level organization unit found with parentId: null"
      );
    }

    if (!topOrg.reportingStandardId) {
      this.logger.warn(
        `No reportingStandardId found for the org named ${topOrg.name}`
      );
      throw new Error(
        `No reportingStandardId found for the org named ${topOrg.name}`
      );
    }

    return topOrg.reportingStandardId;
  }

  async getTopOrgUnitId(): Promise<number> {
    const topOrg = await this.client.organisationUnit.findFirst({
      where: {
        parentId: null
      }
    });

    if (!topOrg) {
      throw new Error(
        "No top-level organization unit found with parentId: null"
      );
    }

    return topOrg.id;
  }

  async getOneById(organisationId: number) {
    return this.client.organisationUnit.findFirstOrThrow({
      where: {
        id: organisationId
      }
    });
  }

  async getOrganisationUnitsByIds(
    orgUnitIds: number[]
  ): Promise<OrganisationUnitMinimalDto[]> {
    return this.client.organisationUnit.findMany({
      where: {
        id: { in: orgUnitIds }
      },
      select: {
        id: true,
        name: true,
        parentId: true
      }
    });
  }

  /**
   * Fetches all organisations given optional organisation ids
   */
  async getManyBy(args?: OrganisationUnitArgs): Promise<OrganisationUnitDto[]> {
    const organisations = await this.client.organisationUnit.findMany({
      where: {
        ...(args?.organisationIds && { id: { in: args.organisationIds } })
      },
      include: {
        organisationFacilities: {
          include: {
            facility: {
              include: {
                facilityTags: { include: { tag: true } }
              }
            }
          }
        },
        organisationTags: {
          include: {
            tag: !!args?.includeTags
          }
        }
      }
    });

    const transformedOrganisations: OrganisationUnitDto[] = organisations.map(
      ({ organisationFacilities, organisationTags, ...org }) => ({
        ...org,
        facilities: organisationFacilities.flatMap((orgFacility) => {
          if (!orgFacility.facility) {
            return [];
          }

          // Append facility tags too
          const facilityTags = orgFacility.facility.facilityTags.flatMap(
            (facTag) => (facTag.tag ? [facTag.tag] : [])
          );

          return [{ ...orgFacility.facility, tags: facilityTags }];
        }),
        tags: organisationTags.flatMap((orgTag) =>
          orgTag.tag ? [orgTag.tag] : []
        )
      })
    );

    return transformedOrganisations;
  }

  async getDistinctOrgs(
    filterBy: EmissionsFilterBy
  ): Promise<OrganisationUnitDto[]> {
    return this.client.organisationUnit.findMany({
      where: {
        emissionOutputs: {
          some: filterBy
        }
      }
    });
  }

  async createOrganisation(
    newOrganisation: OrganisationCreateArgs,
    financialYears: FinancialYearInputArgs[],
    financialQuarters: FinancialQuarterInputArgs[]
  ) {
    return this.client.$transaction(async (tx) => {
      const organisation = await tx.organisationUnit.create({
        data: {
          name: newOrganisation.name,
          description: newOrganisation.description,
          parentId: newOrganisation.parentId,
          dateFrom: newOrganisation.startDate,
          ...(newOrganisation.endDate && { dateTo: newOrganisation.endDate }),
          reportingStandardId: newOrganisation.reportingStandardId,
          consolidationApproachId: newOrganisation.consolidationApproachId,
          // Default settings
          isActive: true,
          isReportingUnit: true
        }
      });

      await Promise.all([
        // Create financial years
        tx.financialYear.createMany({
          data: financialYears.map((fy) => ({
            startMonthId: fy.startMonthId,
            endMonthId: fy.endMonthId,
            organisationUnitId: organisation.id,
            isBaseYear: fy.isBaseYear ?? false,
            label: fy.label,
            locked: fy.isLocked ?? false,
            isForecastBaseYear: fy.isForecastBaseYear ?? false
          }))
        }),
        // Create financial quarters
        tx.financialQuarter.createMany({
          data: financialQuarters.map((fq) => ({
            startMonthId: fq.startMonthId,
            endMonthId: fq.endMonthId,
            organisationUnitId: organisation.id,
            label: fq.label
          }))
        })
      ]);

      if (newOrganisation.organisationTagIds) {
        // Link tags to organisation
        await tx.organisationTag.deleteMany({
          where: {
            organisationUnitId: organisation.id
          }
        });
        await tx.organisationTag.createMany({
          data: newOrganisation.organisationTagIds.map((tagId) => ({
            organisationUnitId: organisation.id,
            tagId: tagId
          }))
        });
      }

      return organisation;
    });
  }

  async updateOrganisation(
    organisationId: number,
    updatedOrganisation: OrganisationUpdateArgs
  ) {
    const {
      name,
      description,
      parentId,
      endDate,
      isReportingUnit,
      reportingStandardId,
      consolidationApproachId,
      companyLogo,
      organisationTagIds
    } = updatedOrganisation;

    const inputArgs: TenantPrisma.OrganisationUnitUncheckedUpdateInput = {};

    if (name) {
      inputArgs.name = name;
    }
    if (description) {
      inputArgs.description = description;
    }
    if (parentId) {
      inputArgs.parentId = parentId;
    }
    if (endDate) {
      inputArgs.dateFrom = endDate;
    }
    if (typeof isReportingUnit === "boolean") {
      inputArgs.isReportingUnit = isReportingUnit;
    }
    if (reportingStandardId) {
      inputArgs.reportingStandardId = reportingStandardId;
    }
    if (consolidationApproachId) {
      inputArgs.consolidationApproachId = consolidationApproachId;
    }
    if (companyLogo) {
      inputArgs.companyLogo = companyLogo;
    }

    const existingOrg = await this.client.organisationUnit.findFirst({
      where: { id: organisationId, dateTo: null }
    });

    if (!existingOrg) {
      throw new Error(
        "Failed to update organisation. Organisation already has an end date provided."
      );
    }

    return this.client.$transaction(async (tx) => {
      // Link tags to organisation
      if (organisationTagIds) {
        await tx.organisationTag.deleteMany({
          where: {
            organisationUnitId: organisationId
          }
        });
        await tx.organisationTag.createMany({
          data: organisationTagIds.map((tagId) => ({
            organisationUnitId: organisationId,
            tagId: tagId
          }))
        });
      }

      return this.client.organisationUnit.update({
        where: { id: organisationId },
        data: inputArgs
      });
    });
  }

  async deleteOrganisations(organisationIds: number[]): Promise<void> {
    return this.client.$transaction(async (prisma) => {
      // Delete organisation as well as tags, financial years and financial quarters, and facility associations
      await Promise.all([
        prisma.organisationUnit.deleteMany({
          where: {
            id: {
              in: organisationIds
            }
          }
        }),
        prisma.organisationTag.deleteMany({
          where: {
            organisationUnitId: {
              in: organisationIds
            }
          }
        }),
        prisma.financialYear.deleteMany({
          where: {
            organisationUnitId: {
              in: organisationIds
            }
          }
        }),
        prisma.financialQuarter.deleteMany({
          where: {
            organisationUnitId: {
              in: organisationIds
            }
          }
        }),
        prisma.organisationFacility.deleteMany({
          where: {
            organisationUnitId: {
              in: organisationIds
            }
          }
        })
      ]);
    });
  }

  async getOrganisationHierarchy(
    orgUnitIds?: number[]
  ): Promise<OrganisationHierarchy> {
    const orgUnits = await this.getManyBy({ organisationIds: orgUnitIds });

    return new OrganisationHierarchy(orgUnits);
  }

  async bulkUploadOrganisations(
    {
      organisationUnits,
      existingTagMap,
      tagsToCreate,
      rootOrgFinancialYears,
      rootOrgFinancialQuarters
    }: BulkOrganisationUploadInput,
    processedFacilities?: FacilityTemplateProcessingResult,
    facilityMap?: Map<string, string[]>
  ): Promise<number> {
    return this.client.$transaction(async (tx) => {
      // Create a mutable copy of the tag map to add newly created tags
      const tagMap = new Map(existingTagMap);

      // Create new tags within the transaction
      if (tagsToCreate.length > 0) {
        const createdTags = await Promise.all(
          tagsToCreate.map((tag) => tx.tag.create({ data: tag }))
        );
        for (const tag of createdTags) {
          tagMap.set(tag.name, tag.id);
        }
      }

      const orgIdMap = new Map<string, number>(); // name -> id

      // Create organisations in order (root first, then children)
      for (let i = 0; i < organisationUnits.length; i++) {
        const orgUnit = organisationUnits[i]!;
        const isRoot = i === 0;

        const parentId = orgUnit.parentName
          ? orgIdMap.get(orgUnit.parentName)
          : undefined;

        const organisation = await tx.organisationUnit.create({
          data: {
            name: orgUnit.name,
            description: orgUnit.description,
            parentId,
            dateFrom: orgUnit.startDate,
            ...(orgUnit.endDate && { dateTo: orgUnit.endDate }),
            reportingStandardId: orgUnit.reportingStandardId,
            consolidationApproachId: orgUnit.consolidationApproachId,
            isActive: true,
            isReportingUnit: true
          }
        });

        orgIdMap.set(orgUnit.name, organisation.id);

        // Create financial years and quarters for each org
        await Promise.all([
          tx.financialYear.createMany({
            data: rootOrgFinancialYears.map((fy) => ({
              startMonthId: fy.startMonthId,
              endMonthId: fy.endMonthId,
              organisationUnitId: organisation.id,
              isBaseYear: isRoot ? (fy.isBaseYear ?? false) : false,
              label: fy.label,
              locked: fy.isLocked ?? false,
              isForecastBaseYear: isRoot
                ? (fy.isForecastBaseYear ?? false)
                : false
            }))
          }),
          tx.financialQuarter.createMany({
            data: rootOrgFinancialQuarters.map((fq) => ({
              startMonthId: fq.startMonthId,
              endMonthId: fq.endMonthId,
              organisationUnitId: organisation.id,
              label: fq.label
            }))
          })
        ]);

        // Link organisation tags to organisation
        if (orgUnit.tags.length > 0) {
          await tx.organisationTag.createMany({
            data: orgUnit.tags
              .filter((tagName) => tagMap.has(tagName))
              .map((tagName) => ({
                organisationUnitId: organisation.id,
                tagId: tagMap.get(tagName)
              }))
          });
        }
      }

      // Create facilities and associate to organisations
      if (processedFacilities && facilityMap) {
        const facilityIdMap = new Map<string, number>(); // name -> id

        const isSharedMap = new Map<string, number>();
        for (const facilities of facilityMap.values()) {
          for (const facilityName of facilities) {
            isSharedMap.set(
              facilityName,
              (isSharedMap.get(facilityName) ?? 0) + 1
            );
          }
        }

        for (const facilityUnit of processedFacilities.facilities) {
          const facility = await tx.facility.create({
            data: {
              name: facilityUnit.name,
              description: facilityUnit.description,
              address: facilityUnit.addressLine1,
              suburb: facilityUnit.addressLine2,
              country: facilityUnit.country,
              postalCode: facilityUnit.postalCode,
              city: facilityUnit.city,
              isSharedFacility: (isSharedMap.get(facilityUnit.name) ?? 0) > 1,
              isActive: true,
              isReportingUnit: true
            }
          });
          facilityIdMap.set(facilityUnit.name, facility.id);
        }

        // Associate facilities to organisations
        for (const [orgName, facilityNames] of facilityMap.entries()) {
          const orgId = orgIdMap.get(orgName);
          if (!orgId || facilityNames.length === 0) {
            continue;
          }

          for (const facilityName of facilityNames) {
            const facilityId = facilityIdMap.get(facilityName);
            if (!facilityId) {
              continue;
            }

            await tx.organisationFacility.create({
              data: {
                organisationUnitId: orgId,
                facilityId: facilityId
              }
            });
          }
        }

        // create facility tags
        for (const facilityUnit of processedFacilities.facilities) {
          const facilityId = facilityIdMap.get(facilityUnit.name);
          if (!facilityId || facilityUnit.tags.length === 0) {
            continue;
          }

          const tagIds = facilityUnit.tags
            .map((tagName) => processedFacilities.existingTagMap.get(tagName))
            .filter((tagId): tagId is string => !!tagId);

          if (tagIds.length === 0) {
            continue;
          }

          await tx.facilityTag.createMany({
            data: tagIds.map((tagId) => ({
              facilityId: facilityId,
              tagId: tagId
            }))
          });
        }
      }

      return organisationUnits.length;
    }, this.transactionOptions);
  }
}
