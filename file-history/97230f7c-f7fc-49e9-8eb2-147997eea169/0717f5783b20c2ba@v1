import { ILogger } from "@generatezero/ports/logger";
import dayjs from "dayjs";
import utc from "dayjs/plugin/utc";

import { OrganisationServiceError } from "../services/Organisation.service";

dayjs.extend(utc);

import { AbstractTemplateCsvParser } from "./AbstractTemplateCsvParser";
import { ORGANISATION_TEMPLATE_CSV_COLUMNS } from "./constants/OrganisationTemplateCsvParser.constants";
import {
  OrganisationTemplateColumnIndices,
  ParsedOrganisationUnit
} from "./interfaces/OrganisationTemplateCsvParser.interfaces";

export class OrganisationTemplateCsvParser extends AbstractTemplateCsvParser {
  constructor(logger: ILogger) {
    super(logger);
  }

  /**
   * Parses organisation template buffer into organisation units
   */
  parseOrganisationTemplateBuffer(buffer: Buffer): {
    organisationUnits: ParsedOrganisationUnit[];
    tagsSet: Set<string>;
  } {
    const fileContent = this.parseBufferToString(buffer);
    return this.processCsvContent(fileContent);
  }

  /**
   * Processes CSV content and returns parsed organisation units and tags
   */
  private processCsvContent(fileContent: string): {
    organisationUnits: ParsedOrganisationUnit[];
    tagsSet: Set<string>;
  } {
    this.validateCsvFormat(fileContent);

    // Parse CSV content
    const parsedData = this.parseCsvContent(fileContent);

    // Validate and extract structure
    const { columnIndices } = this.validateAndExtractCsvStructure(parsedData);

    return this.processOrganisationUnits(parsedData, columnIndices);
  }

  /**
   * Validates CSV structure and extracts column indices
   */
  private validateAndExtractCsvStructure(parsedData: string[][]): {
    headerRow: string[];
    columnIndices: OrganisationTemplateColumnIndices;
  } {
    this.validateMinimumRows(parsedData, "organisational unit");

    const headerRow = parsedData[0];
    if (!headerRow || headerRow.length < 7) {
      throw new OrganisationServiceError(
        "File must contain at least seven columns: Name, Description, Hierarchy, Facilities, Reporting Start Date, Reporting End Date, Tags"
      );
    }

    // Find column indices by header name (case-insensitive)
    const normalizedHeaders = this.normalizeHeaders(headerRow);

    // Map required columns
    const columnIndices: OrganisationTemplateColumnIndices = {
      name: this.findColumnIndex(
        normalizedHeaders,
        ORGANISATION_TEMPLATE_CSV_COLUMNS.NAME
      ),
      description: this.findColumnIndex(
        normalizedHeaders,
        ORGANISATION_TEMPLATE_CSV_COLUMNS.DESCRIPTION
      ),
      hierarchy: this.findColumnIndex(
        normalizedHeaders,
        ORGANISATION_TEMPLATE_CSV_COLUMNS.HIERARCHY
      ),
      facilities: this.findColumnIndex(
        normalizedHeaders,
        ORGANISATION_TEMPLATE_CSV_COLUMNS.FACILITIES
      ),
      startDate: this.findColumnIndex(
        normalizedHeaders,
        ORGANISATION_TEMPLATE_CSV_COLUMNS.REPORTING_START_DATE
      ),
      endDate: this.findColumnIndex(
        normalizedHeaders,
        ORGANISATION_TEMPLATE_CSV_COLUMNS.REPORTING_END_DATE
      ),
      tags: this.findColumnIndex(
        normalizedHeaders,
        ORGANISATION_TEMPLATE_CSV_COLUMNS.TAGS
      )
    };

    return { headerRow, columnIndices };
  }

  /**
   * Processes CSV rows into organisation units
   */
  private processOrganisationUnits(
    parsedData: string[][],
    columnIndices: OrganisationTemplateColumnIndices
  ): {
    organisationUnits: ParsedOrganisationUnit[];
    tagsSet: Set<string>;
  } {
    const dataRows = parsedData.slice(1); // Skip header row
    const organisationUnits: ParsedOrganisationUnit[] = [];
    const tagsSet: Set<string> = new Set();

    for (let i = 0; i < dataRows.length; i++) {
      const row = dataRows[i];
      if (!row) {
        continue;
      }

      const name = row[columnIndices.name]?.trim();
      if (!name) {
        this.logger.warn(`Skipping row ${i + 2}: missing name`);
        continue;
      }

      const description = row[columnIndices.description]?.trim() || undefined;
      const parentName = row[columnIndices.hierarchy]?.trim() || undefined;
      const facilitiesStr = row[columnIndices.facilities]?.trim() || "";
      const startDateStr = row[columnIndices.startDate]?.trim();
      const endDateStr = row[columnIndices.endDate]?.trim() || undefined;
      const tagsStr = row[columnIndices.tags]?.trim() || undefined;

      const startDate = this.parseDate(startDateStr);
      if (!startDate) {
        this.logger.warn(
          `Skipping row ${i + 2}: invalid or missing start date`
        );
        continue;
      }
      const endDate = this.parseDate(endDateStr);

      const facilities = this.parseListFromCell(facilitiesStr);
      const tags = this.parseTags(tagsStr, tagsSet);

      organisationUnits.push({
        name,
        description,
        parentName,
        facilities,
        startDate,
        endDate,
        tags
      });
    }

    this.validateHierarchy(organisationUnits);

    return {
      organisationUnits,
      tagsSet
    };
  }

  /**
   * Parses date string in DD/MM/YYYY or YYYY-MM-DD format
   */
  private parseDate(dateStr: string | undefined): Date | undefined {
    if (!dateStr) {
      return undefined;
    }

    // Try DD/MM/YYYY format
    const ddmmyyyyMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (ddmmyyyyMatch) {
      const [, day, month, year] = ddmmyyyyMatch;
      return new Date(parseInt(year!), parseInt(month!) - 1, parseInt(day!));
    }

    // Try YYYY-MM-DD format
    const yyyymmddMatch = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
    if (yyyymmddMatch) {
      const [, year, month, day] = yyyymmddMatch;
      return new Date(parseInt(year!), parseInt(month!) - 1, parseInt(day!));
    }

    this.logger.warn(`Could not parse date: ${dateStr}`);
    return undefined;
  }

  /**
   * Validates that all hierarchy references point to valid organisation names
   */
  private validateHierarchy(orgUnits: ParsedOrganisationUnit[]): void {
    const orgNames = new Set(orgUnits.map((u) => u.name));

    // Validate that the first org is the root (has no parent)
    const firstOrg = orgUnits[0];
    if (firstOrg?.parentName) {
      throw new OrganisationServiceError(
        `The first organisation "${firstOrg.name}" must be the root organisation (no parent). Found parent: "${firstOrg.parentName}"`
      );
    }

    // Validate there is exactly one root org (no parent)
    const rootOrgs = orgUnits.filter((u) => !u.parentName);
    if (rootOrgs.length > 1) {
      const rootNames = rootOrgs.map((u) => u.name).join(", ");
      throw new OrganisationServiceError(
        `Only one root organisation is allowed. Found ${rootOrgs.length} organisations without a parent: ${rootNames}`
      );
    }

    // Validate that all hierarchy references point to valid organisation names
    for (const orgUnit of orgUnits) {
      if (orgUnit.parentName && !orgNames.has(orgUnit.parentName)) {
        throw new OrganisationServiceError(
          `Organisation "${orgUnit.name}" references unknown parent "${orgUnit.parentName}"`
        );
      }

      // Check for self-reference
      if (orgUnit.parentName === orgUnit.name) {
        throw new OrganisationServiceError(
          `Organisation "${orgUnit.name}" cannot be its own parent`
        );
      }
    }

    this.detectCycles(orgUnits);
  }

  /**
   * Detects cycles in the organisation hierarchy
   */
  private detectCycles(orgUnits: ParsedOrganisationUnit[]): void {
    const orgUnitMap = new Map(orgUnits.map((u) => [u.name, u]));

    for (const orgUnit of orgUnits) {
      const visited = new Set<string>();
      let current: ParsedOrganisationUnit | undefined = orgUnit;

      while (current) {
        if (visited.has(current.name)) {
          throw new OrganisationServiceError(
            `Cycle detected in organisation hierarchy involving "${current.name}"`
          );
        }
        visited.add(current.name);
        current = current.parentName
          ? orgUnitMap.get(current.parentName)
          : undefined;
      }
    }
  }
}
