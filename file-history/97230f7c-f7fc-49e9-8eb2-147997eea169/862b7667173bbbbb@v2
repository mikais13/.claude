import { ILogger } from "@generatezero/ports/logger";
import dayjs from "dayjs";
import utc from "dayjs/plugin/utc";

import { ORGANISATION_TEMPLATE_CSV_COLUMNS } from "../constants/OrganisationTemplateCsvParser.constants";
import { OrganisationTemplateCsvParser } from "../OrganisationTemplateCsvParser";

dayjs.extend(utc);

const mockLogger: ILogger = {
  info: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
  debug: jest.fn(),
  trace: jest.fn(),
  critical: jest.fn(),
  flush: jest.fn(),
  setService: jest.fn()
};

const CSV_HEADER = Array.from(Object.values(ORGANISATION_TEMPLATE_CSV_COLUMNS));

function createCsvBuffer(rows: string[][]): Buffer {
  const csvContent = rows
    .map((row) =>
      row.map((cell) => (cell.includes(",") ? `"${cell}"` : cell)).join(",")
    )
    .join("\n");
  return Buffer.from(csvContent, "utf8");
}

describe("OrganisationCsvParser", () => {
  let parser: OrganisationTemplateCsvParser;

  beforeEach(() => {
    jest.clearAllMocks();
    parser = new OrganisationTemplateCsvParser(mockLogger);
  });

  it("should parse a valid CSV with single root organisation", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      [
        "Root Org",
        "Description",
        "",
        "",
        "01/01/2024",
        "31/12/2024",
        "tag1, tag2"
      ]
    ]);

    const result = parser.parseOrganisationTemplateBuffer(csvBuffer);

    expect(result.organisationUnits).toHaveLength(1);
    expect(result.organisationUnits[0]).toMatchObject({
      name: "Root Org",
      description: "Description",
      parentName: undefined,
      tags: ["tag1", "tag2"]
    });
    expect(result.tagsSet).toEqual(new Set(["tag1", "tag2"]));
  });

  it("should parse a valid CSV with hierarchy", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Parent", "Parent desc", "", "", "01/01/2024", "", ""],
      ["Child A", "Child A desc", "Parent", "", "01/01/2024", "", ""],
      ["Child B", "Child B desc", "Parent", "", "01/01/2024", "", ""],
      ["Grandchild", "Grandchild desc", "Child A", "", "01/01/2024", "", ""]
    ]);

    const result = parser.parseOrganisationTemplateBuffer(csvBuffer);

    expect(result.organisationUnits).toHaveLength(4);
    expect(result.organisationUnits[0]?.parentName).toBeUndefined();
    expect(result.organisationUnits[1]?.parentName).toBe("Parent");
    expect(result.organisationUnits[2]?.parentName).toBe("Parent");
    expect(result.organisationUnits[3]?.parentName).toBe("Child A");
  });

  it("should parse dates in DD/MM/YYYY format", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Org", "", "", "", "15/06/2024", "31/12/2024", ""]
    ]);

    const result = parser.parseOrganisationTemplateBuffer(csvBuffer);

    expect(result.organisationUnits[0]?.startDate).toEqual(
      dayjs.utc("2024-06-15").toDate()
    );
    expect(result.organisationUnits[0]?.endDate).toEqual(
      dayjs.utc("2024-12-31").toDate()
    );
  });

  it("should parse dates in YYYY-MM-DD format", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Org", "", "", "", "2024-06-15", "2024-12-31", ""]
    ]);

    const result = parser.parseOrganisationTemplateBuffer(csvBuffer);

    expect(result.organisationUnits[0]?.startDate).toEqual(
      dayjs.utc("2024-06-15").toDate()
    );
    expect(result.organisationUnits[0]?.endDate).toEqual(
      dayjs.utc("2024-12-31").toDate()
    );
  });

  it("should handle empty optional fields", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Org", "", "", "", "01/01/2024", "", ""]
    ]);

    const result = parser.parseOrganisationTemplateBuffer(csvBuffer);

    expect(result.organisationUnits[0]).toMatchObject({
      name: "Org",
      description: undefined,
      parentName: undefined,
      startDate: dayjs.utc("2024-01-01").toDate(),
      endDate: undefined,
      tags: []
    });
  });

  it("should collect all unique tags", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Org1", "", "", "", "01/01/2024", "", "tag1, tag2"],
      ["Org2", "", "Org1", "", "01/01/2024", "", "tag2, tag3"],
      ["Org3", "", "Org1", "", "01/01/2024", "", "tag1, tag3, tag4"]
    ]);

    const result = parser.parseOrganisationTemplateBuffer(csvBuffer);

    expect(result.tagsSet).toEqual(new Set(["tag1", "tag2", "tag3", "tag4"]));
  });

  it("should skip rows with missing name", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "", "01/01/2024", "", ""],
      ["", "", "Root", "", "01/01/2024", "", ""],
      ["Child", "", "Root", "", "01/01/2024", "", ""]
    ]);

    const result = parser.parseOrganisationTemplateBuffer(csvBuffer);

    expect(result.organisationUnits).toHaveLength(2);
    expect(mockLogger.warn).toHaveBeenCalledWith(
      expect.stringContaining("missing name")
    );
  });

  it("should skip rows with invalid start date", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "", "01/01/2024", "", ""],
      ["Child", "", "Root", "", "invalid-date", "", ""]
    ]);

    const result = parser.parseOrganisationTemplateBuffer(csvBuffer);

    expect(result.organisationUnits).toHaveLength(1);
    expect(mockLogger.warn).toHaveBeenCalledWith(
      expect.stringContaining("invalid or missing start date")
    );
  });

  it("should throw error when CSV has less than 2 rows", () => {
    const csvBuffer = createCsvBuffer([CSV_HEADER]);

    expect(() => parser.parseOrganisationTemplateBuffer(csvBuffer)).toThrow(
      "File must contain at least a header row and one organisational unit"
    );
  });

  it("should throw error when CSV has less than the required columns", () => {
    const csvBuffer = createCsvBuffer([
      ["Name", "Description", "Hierarchy"],
      ["Org", "", ""]
    ]);

    expect(() => parser.parseOrganisationTemplateBuffer(csvBuffer)).toThrow(
      "File must contain at least seven columns"
    );
  });

  it("should throw error when required column is missing", () => {
    const csvBuffer = createCsvBuffer([
      [
        "Name",
        "Description",
        "Wrong Column",
        "Facilities",
        "Start Date",
        "End Date",
        "Tags"
      ],
      ["Org", "", "", "", "01/01/2024", "", ""]
    ]);

    expect(() => parser.parseOrganisationTemplateBuffer(csvBuffer)).toThrow(
      "Missing required column: Hierarchy"
    );
  });

  it("should throw error when organisation references unknown parent", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "", "01/01/2024", "", ""],
      ["Child", "", "NonExistent", "", "01/01/2024", "", ""]
    ]);

    expect(() => parser.parseOrganisationTemplateBuffer(csvBuffer)).toThrow(
      'Organisation "Child" references unknown parent "NonExistent"'
    );
  });

  it("should throw error when organisation is its own parent", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "", "01/01/2024", "", ""],
      ["SelfRef", "", "SelfRef", "", "01/01/2024", "", ""]
    ]);

    expect(() => parser.parseOrganisationTemplateBuffer(csvBuffer)).toThrow(
      'Organisation "SelfRef" cannot be its own parent'
    );
  });

  it("should throw error when cycle is detected in hierarchy", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "", "01/01/2024", "", ""],
      ["A", "", "C", "", "01/01/2024", "", ""],
      ["B", "", "A", "", "01/01/2024", "", ""],
      ["C", "", "B", "", "01/01/2024", "", ""]
    ]);

    expect(() => parser.parseOrganisationTemplateBuffer(csvBuffer)).toThrow(
      /Cycle detected/
    );
  });

  it("should throw error when first organisation has a parent", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Child", "", "SomeParent", "", "01/01/2024", "", ""],
      ["SomeParent", "", "", "", "01/01/2024", "", ""]
    ]);

    expect(() => parser.parseOrganisationTemplateBuffer(csvBuffer)).toThrow(
      'The first organisation "Child" must be the root organisation (no parent). Found parent: "SomeParent"'
    );
  });

  it("should throw error when multiple root organisations exist", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root1", "", "", "", "01/01/2024", "", ""],
      ["Root2", "", "", "", "01/01/2024", "", ""],
      ["Child", "", "Root1", "", "01/01/2024", "", ""]
    ]);

    expect(() => parser.parseOrganisationTemplateBuffer(csvBuffer)).toThrow(
      "Only one root organisation is allowed. Found 2 organisations without a parent: Root1, Root2"
    );
  });

  it("should throw error when three root organisations exist", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root1", "", "", "", "01/01/2024", "", ""],
      ["Root2", "", "", "", "01/01/2024", "", ""],
      ["Root3", "", "", "", "01/01/2024", "", ""]
    ]);

    expect(() => parser.parseOrganisationTemplateBuffer(csvBuffer)).toThrow(
      "Only one root organisation is allowed. Found 3 organisations without a parent: Root1, Root2, Root3"
    );
  });

  it("should accept valid single root organisation", () => {
    const csvBuffer = createCsvBuffer([
      CSV_HEADER,
      ["Root", "", "", "", "01/01/2024", "", ""],
      ["Child1", "", "Root", "", "01/01/2024", "", ""],
      ["Child2", "", "Root", "", "01/01/2024", "", ""]
    ]);

    const result = parser.parseOrganisationTemplateBuffer(csvBuffer);

    expect(result.organisationUnits).toHaveLength(3);
    expect(result.organisationUnits[0]?.parentName).toBeUndefined();
    expect(result.organisationUnits[1]?.parentName).toBe("Root");
    expect(result.organisationUnits[2]?.parentName).toBe("Root");
  });
});
